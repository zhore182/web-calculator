---
phase: 04-graphing-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/logic/graphRenderer.ts
  - src/logic/graphRenderer.test.ts
  - src/styles/Calculator.css
  - src/components/GraphPanel.tsx
autonomous: true

must_haves:
  truths:
    - "A Canvas element renders labeled X and Y axes with tick marks and grid lines"
    - "A mathematical function expression evaluates at sampled x-values to produce y-values for plotting"
    - "A curve is drawn on the Canvas connecting sampled points of the function"
    - "The coordinate system maps between pixel space and math space correctly"
  artifacts:
    - path: "src/logic/graphRenderer.ts"
      provides: "Canvas rendering functions for axes, grid, and function curves"
      exports: ["renderGraph", "GraphConfig"]
    - path: "src/logic/graphRenderer.test.ts"
      provides: "Unit tests for coordinate transform and sampling logic"
    - path: "src/components/GraphPanel.tsx"
      provides: "React component wrapping Canvas with ref-based rendering"
      exports: ["GraphPanel"]
  key_links:
    - from: "src/components/GraphPanel.tsx"
      to: "src/logic/graphRenderer.ts"
      via: "renderGraph() called in useEffect with canvas ref"
      pattern: "renderGraph\\(ctx"
    - from: "src/logic/graphRenderer.ts"
      to: "mathjs evaluate"
      via: "evaluateExpression from expressionParser.ts for f(x) sampling"
      pattern: "evaluateExpression"
---

<objective>
Build the graph rendering engine and GraphPanel component that can draw a 2D function plot on an HTML5 Canvas element with labeled axes, grid lines, and a function curve.

Purpose: This is the visual foundation for graphing — without it, no function can be plotted. Separates pure rendering logic from the React component for testability.
Output: `graphRenderer.ts` (pure rendering functions), `graphRenderer.test.ts` (unit tests), `GraphPanel.tsx` (React Canvas wrapper)
</objective>

<execution_context>
@/Users/angel-ai/.claude/get-shit-done/workflows/execute-plan.md
@/Users/angel-ai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/logic/expressionParser.ts
@src/styles/Calculator.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create graph rendering engine with axes, grid, and curve plotting</name>
  <files>src/logic/graphRenderer.ts, src/logic/graphRenderer.test.ts</files>
  <action>
Create `src/logic/graphRenderer.ts` with pure rendering functions:

**GraphConfig interface:**
```typescript
interface GraphConfig {
  width: number;       // Canvas pixel width
  height: number;      // Canvas pixel height
  xMin: number;        // Math x-axis minimum (default: -10)
  xMax: number;        // Math x-axis maximum (default: 10)
  yMin: number;        // Math y-axis minimum (default: -10)
  yMax: number;        // Math y-axis maximum (default: 10)
  angleMode: 'DEG' | 'RAD';
}
```

**Coordinate transform functions (pure, testable):**
- `mathToPixelX(mathX, config)` — converts math x-coordinate to canvas pixel x
- `mathToPixelY(mathY, config)` — converts math y-coordinate to canvas pixel y (note: y is flipped in canvas)
- `pixelToMathX(pixelX, config)` — inverse transform (needed later for trace, but add now for completeness)
- `pixelToMathY(pixelY, config)` — inverse transform

**Axis and grid rendering:**
- `renderAxes(ctx, config)` — Draw x-axis and y-axis lines. Axes should be drawn at y=0 and x=0 positions (shifted if origin is off-screen). Color: `#666`. Line width: 1.5px.
- `renderGrid(ctx, config)` — Draw grid lines at integer tick intervals. Use adaptive tick spacing: if range > 20, use step=5; if range > 100, step=10; otherwise step=1. Color: `rgba(100,100,100,0.2)`. Line width: 0.5px.
- `renderTickLabels(ctx, config)` — Draw numeric labels at tick marks along axes. Font: `11px monospace`. Color: `#888`. Labels should be offset slightly from axes for readability. Skip label at origin to avoid overlap.

**Function curve rendering:**
- `sampleFunction(expression, config)` — Evaluate the expression at N evenly-spaced x-values across [xMin, xMax]. Use `evaluateExpression` from `expressionParser.ts` by replacing `x` in the expression with the numeric value. Use mathjs `evaluate()` directly with a scope containing `{x: value}` plus the angle mode scope from expressionParser patterns. Sample count: `config.width` points (1 sample per pixel column) for smooth curves. Return array of `{x, y}` where y can be `null` for undefined points.
- `renderCurve(ctx, points, config)` — Draw the sampled points as a connected path. Use `moveTo`/`lineTo`. Skip null y-values (create gaps in the curve for discontinuities like tan at pi/2). Curve color: `#4a9eff` (matching the calculator's accent blue). Line width: 2px.

**Main render function:**
- `renderGraph(ctx, expression, config)` — Orchestrates: clear canvas, render grid, render axes, render tick labels, sample function, render curve. If expression is empty, only render the empty coordinate system (grid + axes + labels).

**Important implementation notes:**
- Use the same angle mode scope pattern from `expressionParser.ts` (DEG mode overrides trig functions in scope) when sampling f(x)
- For the expression evaluation, use mathjs `evaluate()` directly with scope `{x: xValue, sin: ..., cos: ..., log: ..., ln: ...}` matching the existing angle mode and log aliasing pattern
- Handle evaluation errors gracefully — if a point fails to evaluate, set y=null for that sample
- Import `evaluate` from 'mathjs' directly (same as expressionParser.ts does)

**Unit tests in `graphRenderer.test.ts`:**
- Test coordinate transforms: mathToPixelX/Y with known config returns expected pixel values
- Test coordinate transforms: pixelToMathX/Y is inverse of mathToPixelX/Y
- Test sampleFunction: "x" expression returns identity line points
- Test sampleFunction: "x^2" returns correct parabola values
- Test sampleFunction: invalid expression returns all null y-values
  </action>
  <verify>Run `npm test` — all new graphRenderer tests pass. Run `npm run build` — no TypeScript errors.</verify>
  <done>Coordinate transform functions correctly map between math and pixel space. sampleFunction evaluates expressions at x-values using mathjs with angle mode support. All rendering functions exist and tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create GraphPanel React component with Canvas rendering</name>
  <files>src/components/GraphPanel.tsx, src/styles/Calculator.css</files>
  <action>
Create `src/components/GraphPanel.tsx`:

**GraphPanel component:**
```typescript
interface GraphPanelProps {
  expression: string;        // The function expression to plot (e.g., "sin(x)", "x^2")
  angleMode: 'DEG' | 'RAD';
  visible: boolean;          // Whether graph panel is shown
}
```

- Use `useRef<HTMLCanvasElement>` for canvas reference
- Use `useEffect` to call `renderGraph()` whenever expression, angleMode, or visible changes
- Canvas size: 280px wide x 200px tall (fits within calculator's 320px max-width with padding). Use CSS for display size and set canvas width/height attributes for resolution (multiply by `window.devicePixelRatio` for crisp rendering on retina, scale context accordingly).
- Wrap canvas in a container div with class `graph-panel`
- When `visible` is false, render nothing (return null) — don't render a hidden canvas

**CSS additions to `src/styles/Calculator.css`:**

Add graph panel styles:
```css
.graph-panel {
  margin-top: 12px;
  border-top: 1px solid #3a3a3a;
  padding-top: 12px;
}

.graph-panel__canvas {
  width: 100%;
  height: 200px;
  border-radius: 6px;
  background: #1a1a1a;
  display: block;
}
```

Add responsive overrides in existing media queries:
- Tablet (481-768px): canvas height 180px
- Phone (max-width 480px): canvas height 160px
- Narrow phone (max-width 340px): canvas height 140px

Default GraphConfig when rendering: xMin=-10, xMax=10, yMin=-10, yMax=10. These are hardcoded defaults for Phase 4 (zoom/pan comes in Phase 5).
  </action>
  <verify>Run `npm run build` — no TypeScript errors. The component is created and can be imported.</verify>
  <done>GraphPanel component renders a Canvas element. When given an expression and angle mode, it draws axes, grid, labels, and the function curve. When expression is empty, it shows an empty coordinate system. Responsive sizing works across breakpoints.</done>
</task>

</tasks>

<verification>
1. `npm test` — all existing tests still pass, new graphRenderer tests pass
2. `npm run build` — no TypeScript compilation errors
3. GraphPanel component exists and exports correctly
4. graphRenderer.ts exports renderGraph and GraphConfig
</verification>

<success_criteria>
- Canvas-based graph rendering engine with coordinate transforms, axes, grid, labels, and curve plotting
- GraphPanel React component wraps canvas with ref-based rendering
- Function expressions evaluate at sampled x-values using mathjs with angle mode support
- Unit tests verify coordinate transforms and function sampling
</success_criteria>

<output>
After completion, create `.planning/phases/04-graphing-core/04-01-SUMMARY.md`
</output>
