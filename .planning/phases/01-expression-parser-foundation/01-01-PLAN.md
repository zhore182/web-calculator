---
phase: 01-expression-parser-foundation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/logic/expressionParser.ts
  - src/logic/expressionParser.test.ts
autonomous: true

must_haves:
  truths:
    - "Expression '2+3*4' evaluates to 14 (PEMDAS, not 20)"
    - "Expression '2*(3+4)' evaluates to 14 (parentheses)"
    - "Expression '2(3)' evaluates to 6 (implicit multiplication)"
    - "Expression '2++3' returns a syntax error, not a crash"
    - "Expression '2+3*' returns incomplete/error status, not a crash"
  artifacts:
    - path: "src/logic/expressionParser.ts"
      provides: "PEMDAS expression evaluation engine"
      exports: ["evaluateExpression", "ExpressionResult", "ExpressionMode"]
    - path: "src/logic/expressionParser.test.ts"
      provides: "Comprehensive parser tests"
      min_lines: 80
  key_links:
    - from: "src/logic/expressionParser.ts"
      to: "mathjs"
      via: "import and evaluate()"
      pattern: "import.*mathjs"
---

<objective>
Build a PEMDAS-capable expression evaluation engine using mathjs, with comprehensive tests proving correct operator precedence, parentheses handling, implicit multiplication, and error boundaries.

Purpose: This is the computational foundation for the entire expression parser phase. All subsequent plans depend on this engine being correct and robust. Replaces the legacy left-to-right `calculate()` function for expression mode.

Output: `src/logic/expressionParser.ts` with exported `evaluateExpression()` function and types, plus test suite.
</objective>

<execution_context>
@/Users/angel-ai/.claude/get-shit-done/workflows/execute-plan.md
@/Users/angel-ai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/logic/operationHandlers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install mathjs and create expression parser with TDD</name>
  <files>
    package.json
    package-lock.json
    src/logic/expressionParser.ts
    src/logic/expressionParser.test.ts
  </files>
  <action>
**Install mathjs:**
```bash
npm install mathjs
```

**RED phase — Write failing tests first in `src/logic/expressionParser.test.ts`:**

Define test cases for `evaluateExpression(expr: string): ExpressionResult` where `ExpressionResult` is:
```typescript
interface ExpressionResult {
  status: 'success' | 'error' | 'incomplete';
  value?: number;
  display?: string;  // Formatted result string
  error?: string;    // Error message (e.g., "Syntax Error")
}
```

Also define and export:
```typescript
type ExpressionMode = 'simple' | 'expression';
```

Test groups:
1. **Basic arithmetic with PEMDAS:**
   - `"2+3*4"` → 14 (not 20)
   - `"10-2*3"` → 4
   - `"6/2+1"` → 4
   - `"2+3"` → 5
   - `"10/3"` → result close to 3.333...

2. **Parentheses:**
   - `"(2+3)*4"` → 20
   - `"2*(3+4)"` → 14
   - `"((1+2)*(3+4))"` → 21
   - `"(5)"` → 5

3. **Implicit multiplication (per user decision):**
   - `"2(3)"` → 6
   - `"(2)(3)"` → 6
   - `"2(3+4)"` → 14

4. **Error handling:**
   - `"2+3*"` → status 'error', error message present
   - `"2++3"` → status 'error'
   - `")"` → status 'error'
   - `""` → status 'incomplete' or appropriate handling
   - `"/"` → status 'error'

5. **Floating-point precision:**
   - `"0.1+0.2"` → display shows "0.3" (not "0.30000000000000004")
   - `"1/3"` → reasonable decimal representation
   - Large numbers format correctly
   - Very small numbers format correctly

6. **Edge cases:**
   - `"0"` → 0
   - `"-5"` → -5 (unary minus)
   - `"5!"` → test if mathjs handles factorial (prepare for Phase 2)

Run tests — they MUST fail (RED).

**GREEN phase — Implement `src/logic/expressionParser.ts`:**

```typescript
import { evaluate } from 'mathjs';
```

Implement `evaluateExpression(expr: string): ExpressionResult`:
1. If empty string, return `{ status: 'incomplete' }`
2. Wrap `evaluate()` call in try-catch
3. On success: format result using a `formatResult()` helper that:
   - Uses `toPrecision(12)` then strips trailing zeros
   - Returns both numeric value and display string
4. On error: return `{ status: 'error', error: 'Syntax Error' }`

Implement `formatResult(value: number): string`:
- Handle NaN → "Error"
- Handle Infinity → "Error"
- Use `parseFloat(value.toPrecision(12)).toString()` for clean formatting
- This establishes the single precision strategy (addressing Pitfall 2)

Export: `evaluateExpression`, `formatResult`, `ExpressionResult`, `ExpressionMode`

Run tests — they MUST pass (GREEN).

**REFACTOR phase:** Clean up if needed, ensure all exports are properly typed.
  </action>
  <verify>
Run `npm test -- --run src/logic/expressionParser.test.ts` — all tests pass.
Run `npm run build` — no TypeScript errors.
  </verify>
  <done>
evaluateExpression correctly handles PEMDAS, parentheses, implicit multiplication, and returns structured error results instead of throwing. formatResult provides consistent number formatting. All test cases pass.
  </done>
</task>

</tasks>

<verification>
```bash
npm test -- --run src/logic/expressionParser.test.ts
npm run build
```
All parser tests pass. Build succeeds with no type errors.
</verification>

<success_criteria>
- evaluateExpression("2+3*4") returns { status: 'success', value: 14, display: '14' }
- evaluateExpression("2*(3+4)") returns { status: 'success', value: 14, display: '14' }
- evaluateExpression("2(3)") returns { status: 'success', value: 6, display: '6' }
- evaluateExpression("2++3") returns { status: 'error', error: 'Syntax Error' }
- All tests green, build passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-expression-parser-foundation/01-01-SUMMARY.md`
</output>
