---
phase: 01-expression-parser-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/App.tsx
  - src/logic/cursorHelpers.ts
  - src/logic/cursorHelpers.test.ts
  - src/components/Display.tsx
  - src/hooks/useKeyboardInput.ts
  - src/styles/Calculator.css
autonomous: false

must_haves:
  truths:
    - "User can click/tap within expression to position cursor at that point"
    - "User can use arrow keys to move cursor left/right within expression"
    - "Calculator buttons insert characters at cursor position, not always at end"
    - "Backspace deletes the character before the cursor position"
    - "Typing '(' auto-inserts '()' with cursor between the parentheses"
    - "Blinking line cursor visible between characters in expression display"
    - "Incomplete expression on equals press shows 'Syntax Error' in result line"
    - "After error, expression is preserved — user can backspace and correct"
  artifacts:
    - path: "src/logic/cursorHelpers.ts"
      provides: "Pure functions for cursor manipulation and expression editing"
      exports: ["insertAtCursor", "deleteAtCursor", "moveCursor"]
    - path: "src/logic/cursorHelpers.test.ts"
      provides: "Tests for cursor helper functions"
      min_lines: 40
    - path: "src/components/Display.tsx"
      provides: "Cursor rendering within expression line"
      contains: "cursor"
  key_links:
    - from: "src/logic/cursorHelpers.ts"
      to: "src/App.tsx"
      via: "imported and called in handleButtonClick"
      pattern: "insertAtCursor|deleteAtCursor"
    - from: "src/hooks/useKeyboardInput.ts"
      to: "src/App.tsx"
      via: "arrow key and backspace handlers"
      pattern: "ArrowLeft|ArrowRight|Backspace"
    - from: "src/components/Display.tsx"
      to: "src/App.tsx"
      via: "onClick handler for cursor positioning"
      pattern: "onExpressionClick|cursorPosition"
---

<objective>
Implement cursor management for expression editing: click-to-position cursor, arrow key navigation, character insertion at cursor position, auto-close parentheses, backspace, and blinking cursor rendering. This completes the expression editing UX and finalizes the phase.

Purpose: Without cursor management, expression mode is append-only. Users need to edit within expressions — positioning the cursor, inserting at that point, and navigating with arrow keys. This is the difference between a text input and a usable expression editor.

Output: Full expression editing experience with visual cursor, click-to-position, arrow keys, and proper error handling flow.
</objective>

<execution_context>
@/Users/angel-ai/.claude/get-shit-done/workflows/execute-plan.md
@/Users/angel-ai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-expression-parser-foundation/01-01-SUMMARY.md
@.planning/phases/01-expression-parser-foundation/01-02-SUMMARY.md
@src/App.tsx
@src/components/Display.tsx
@src/logic/cursorHelpers.ts
@src/hooks/useKeyboardInput.ts
@src/styles/Calculator.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cursor helper functions and implement expression editing logic</name>
  <files>
    src/logic/cursorHelpers.ts
    src/logic/cursorHelpers.test.ts
    src/App.tsx
  </files>
  <action>
**Create `src/logic/cursorHelpers.ts` with pure functions:**

```typescript
/**
 * Insert text into expression at cursor position.
 * Returns { expression, cursorPosition } after insertion.
 */
export function insertAtCursor(
  expression: string,
  cursorPosition: number,
  text: string
): { expression: string; cursorPosition: number }

/**
 * Delete character before cursor position (backspace behavior).
 * Returns { expression, cursorPosition } after deletion.
 */
export function deleteAtCursor(
  expression: string,
  cursorPosition: number
): { expression: string; cursorPosition: number }

/**
 * Move cursor left or right within expression bounds.
 * Returns new cursor position, clamped to [0, expression.length].
 */
export function moveCursor(
  cursorPosition: number,
  direction: 'left' | 'right',
  expressionLength: number
): number

/**
 * Insert opening parenthesis with auto-close.
 * Per user decision: typing '(' inserts '()' with cursor between.
 * Returns { expression, cursorPosition }.
 */
export function insertParenthesis(
  expression: string,
  cursorPosition: number,
  type: 'open'
): { expression: string; cursorPosition: number }

/**
 * Calculate cursor position from a click/tap x-coordinate on the expression display.
 * Given character widths and click position, determine which character boundary
 * the cursor should snap to.
 */
export function getCursorPositionFromClick(
  clickOffsetX: number,
  charWidth: number,
  expressionLength: number,
  scrollLeft: number
): number
```

Key behaviors:
- `insertAtCursor`: Splice text into expression at cursor position. Cursor advances by text length.
- `deleteAtCursor`: If cursor at 0, no-op. Otherwise remove character at `cursorPosition - 1`, cursor moves back 1.
- `moveCursor`: Clamp result to `[0, expressionLength]`.
- `insertParenthesis('open')`: Insert `()` at cursor, position cursor between them (cursorPosition + 1).
- Closing `)` typed directly: If cursor is before an auto-inserted `)`, skip over it instead of inserting a second one. Otherwise insert normally.

**Write tests in `src/logic/cursorHelpers.test.ts`:**

Test `insertAtCursor`:
- Insert "5" at position 0 of "" → "5", cursor 1
- Insert "+" at position 1 of "5" → "5+", cursor 2
- Insert "3" at position 1 of "5+" (middle) → "53+", cursor 2 — wait, that's wrong. Insert at position 1 of "5+" means "5" + "3" + "+" → "53+", cursor 2. Actually: expression "5+", insert "3" at pos 1 → "5" + "3" + "+" → "53+", cursor 2. Correct.
- Insert at end of expression

Test `deleteAtCursor`:
- Delete at position 0 → no-op
- Delete at position 3 of "123" → "12", cursor 2
- Delete in middle of expression

Test `moveCursor`:
- Move left from 0 → 0 (clamped)
- Move right from end → end (clamped)
- Move left from 3 → 2
- Move right from 3 → 4

Test `insertParenthesis`:
- Open paren in empty expression → "()", cursor 1
- Open paren at end of "2+" → "2+()", cursor 3

**Update `src/App.tsx` handleButtonClick for expression mode:**

Replace the basic expression append logic (from Plan 02) with cursor-aware editing:

For expression mode button handling:
- **Digits (0-9):** Call `insertAtCursor(expression, cursorPosition, digit)`, update expression and cursor state. Attempt live preview evaluation.
- **Operators (+, -, *, /):** Call `insertAtCursor(expression, cursorPosition, operator)`, update state, attempt preview.
- **Decimal (.):** Call `insertAtCursor(expression, cursorPosition, '.')`, update state, attempt preview.
- **Open parenthesis button:** Call `insertParenthesis(expression, cursorPosition, 'open')`.
- **Close parenthesis button:** Call `insertAtCursor(expression, cursorPosition, ')')`.
- **Backspace:** Call `deleteAtCursor(expression, cursorPosition)`, update state, attempt preview.
- **Equals (=):** Evaluate full expression. On success → set displayValue to result, add to history, clear expression. On error → set previewResult to "Syntax Error", keep expression visible for correction (per user decision).
- **Clear (C):** Reset expression, cursorPosition, previewResult, displayValue.

Add a `handleCursorMove` callback for arrow key events (will be wired in Task 2).

Add a `handleExpressionClick` callback that receives click position data and calls `getCursorPositionFromClick` to set cursor position.

Note: The existing `handleButtonClick` for simple mode must remain EXACTLY as-is. Use an early check: `if (expressionMode === 'expression') { /* expression logic */ return; }` before the existing simple mode code. This preserves simple mode behavior with zero risk of regression.

Add parenthesis buttons '(' and ')' to the button handling logic. These buttons will be added to the ButtonPanel in a future phase (scientific panel), but the handling logic should be ready. For now, they can be triggered via keyboard input.
  </action>
  <verify>
Run `npm test -- --run src/logic/cursorHelpers.test.ts` — all cursor helper tests pass.
Run `npm run build` — no TypeScript errors.
Run `npm test -- --run` — all tests pass including existing ones.
  </verify>
  <done>
Cursor helper functions are implemented and tested. App.tsx handleButtonClick uses cursor-aware editing for expression mode. Characters insert at cursor position. Backspace deletes at cursor position. Parentheses auto-close. Simple mode behavior is completely unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement cursor rendering in Display and keyboard navigation</name>
  <files>
    src/components/Display.tsx
    src/hooks/useKeyboardInput.ts
    src/styles/Calculator.css
  </files>
  <action>
**Update `src/components/Display.tsx` for cursor rendering:**

When in expression mode, render a blinking line cursor between characters:

Implementation approach:
- Split the expression string into two parts: before cursor and after cursor
- Render: `<span>{beforeCursor}</span><span className="cursor">|</span><span>{afterCursor}</span>`
- The cursor element is a thin blinking line (CSS animation)
- Symbol rendering (from Plan 02's `renderExpression`) still applies to both parts
- When expression is empty, show cursor alone (blinking in empty expression line)

Add `onExpressionClick` prop to Display:
```typescript
onExpressionClick?: (position: number) => void;
```

Implement click-to-position:
- The expression line div has an `onClick` handler
- Use a `ref` on the expression container to measure character positions
- Since we use monospace font, calculate position from `event.clientX` relative to container left edge, divided by character width
- Account for scroll position of the expression line
- Call `onExpressionClick` with computed character position
- Round to nearest character boundary

Ensure expression line auto-scrolls to keep cursor visible:
- After cursor position changes, if cursor is near right edge, scroll expression container to show cursor
- Use `useEffect` with `scrollLeft` adjustment on the expression container `ref`

**Update `src/hooks/useKeyboardInput.ts`:**

Add new key mappings for expression mode:
```typescript
// Arrow keys for cursor movement (expression mode only)
'ArrowLeft': 'CURSOR_LEFT',
'ArrowRight': 'CURSOR_RIGHT',

// Backspace for expression editing
'Backspace': 'BACKSPACE',

// Parentheses
'(': '(',
')': ')',
```

The hook needs to know whether expression mode is active to decide how to handle certain keys. Two options:
1. Always pass the mapped value and let App.tsx decide based on mode
2. Pass mode into the hook

Choose option 1 (simpler): Map all keys and let `handleButtonClick` in App.tsx route appropriately. Add 'ArrowLeft', 'ArrowRight', 'Backspace', '(', ')' to the keyMap. In simple mode, App.tsx ignores arrow keys and treats Backspace as a no-op (or could clear last digit — but per current behavior, just ignore).

Updated keyMap additions:
```typescript
'ArrowLeft': 'ArrowLeft',
'ArrowRight': 'ArrowRight',
'Backspace': 'Backspace',
'(': '(',
')': ')',
```

In App.tsx `handleButtonClick`, add handlers:
- `'ArrowLeft'`: In expression mode, call `moveCursor(cursorPosition, 'left', expression.length)`. In simple mode, ignore.
- `'ArrowRight'`: In expression mode, call `moveCursor(cursorPosition, 'right', expression.length)`. In simple mode, ignore.
- `'Backspace'`: In expression mode, call `deleteAtCursor(expression, cursorPosition)`. In simple mode, could clear last digit (stretch) or ignore.

**Add CSS for cursor in `src/styles/Calculator.css`:**

```css
/* Blinking cursor in expression display */
.display__cursor {
  display: inline-block;
  width: 1px;
  height: 1.2em;
  background-color: #1a1a1a;
  animation: blink 1s step-end infinite;
  vertical-align: text-bottom;
  margin: 0 -0.5px;
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}
```

Style the expression line for click interaction:
```css
.display__expression {
  cursor: text;  /* Show text cursor on hover */
}
```

Add responsive adjustments for cursor and expression line on mobile breakpoints.
  </action>
  <verify>
Run `npm run build` — no TypeScript errors.
Run `npm test -- --run` — all tests pass.
Visually: Blinking cursor visible in expression mode. Arrow keys move cursor. Click on expression positions cursor. Backspace deletes at cursor. Auto-close parentheses work.
  </verify>
  <done>
Blinking line cursor renders between characters in expression display. Click/tap on expression positions cursor at that point. Arrow keys move cursor left/right. Keyboard hook handles ArrowLeft, ArrowRight, Backspace, parentheses. Expression line auto-scrolls to keep cursor visible. All keyboard and click interactions work in expression mode. Simple mode is unaffected.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete expression editing experience</name>
  <files>src/App.tsx</files>
  <action>
Human verification checkpoint. All implementation is complete from Tasks 1 and 2. Start dev server with `npm run dev` and verify the complete expression editing experience manually.
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. **Simple mode (default):**
   - Verify calculator looks identical to before (no visual regression)
   - Type 2 + 3 = → should show 5
   - Type 2 + 3 * 4 = → should show 20 (left-to-right, NOT PEMDAS)
3. **Switch to Expression mode:**
   - Click "Expression" in the mode toggle
   - Verify split display appears (expression line on top, result on bottom)
   - Current value should be preserved after mode switch
4. **PEMDAS evaluation:**
   - Type 2+3*4 → expression shows "2+3×4" on top line (note multiply symbol)
   - Live preview should show "14" on bottom line
   - Press = → result shows 14
5. **Parentheses:**
   - Type 2*(3+4) → should evaluate to 14
   - Type ( → should auto-insert () with cursor between
6. **Cursor editing:**
   - Type "2+3" then press ArrowLeft twice to position cursor before "3"
   - Type "1" → expression should become "2+13"
   - Click/tap on a character in the expression to reposition cursor
   - Verify blinking cursor is visible between characters
7. **Backspace:**
   - In expression "2+3", press Backspace → "2+"
   - Verify cursor position updates correctly
8. **Error handling:**
   - Type "2+3*" and press = → should show "Syntax Error" in result line
   - Expression "2+3*" should remain visible on top line
   - Press Backspace to delete "*", then press = → should show 5
9. **Implicit multiplication:**
   - Type "2(3)" and press = → should show 6
10. **Mode switching preserves state:**
    - In expression mode, evaluate "2+3" = 5
    - Switch to Simple mode → display should show 5
    - Switch back to Expression → display should show 5, expression empty
  </verify>
  <done>All 10 verification checks pass. Expression editing is fully functional with PEMDAS evaluation, cursor management, error handling, and mode switching.</done>
</task>

</tasks>

<verification>
```bash
npm run build
npm test -- --run
npm run dev  # Manual verification of all expression editing features
```
Build passes. All tests pass. Manual verification confirms all expression editing features work correctly.
</verification>

<success_criteria>
- Blinking cursor visible in expression mode between characters
- Click/tap positions cursor within expression
- Arrow keys navigate cursor left/right
- Buttons insert at cursor position (not always at end)
- Backspace deletes character before cursor
- Auto-close parentheses work
- Incomplete expressions show "Syntax Error" on equals, expression preserved
- After error, user can backspace and correct
- All keyboard inputs (digits, operators, arrows, backspace, parens) work in expression mode
- Simple mode is completely unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/01-expression-parser-foundation/01-03-SUMMARY.md`
</output>
