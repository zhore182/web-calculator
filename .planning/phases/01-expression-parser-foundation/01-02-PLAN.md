---
phase: 01-expression-parser-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/components/Display.tsx
  - src/components/ModeToggle.tsx
  - src/components/Calculator.tsx
  - src/styles/Calculator.css
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User sees a two-line display: expression on top, result on bottom"
    - "User sees a mode toggle control above the display (Simple / Expression)"
    - "Default mode is Simple on page load"
    - "Switching modes preserves the current display value (no reset)"
    - "Both modes use the same split display layout"
    - "Math symbols render in display (not raw operators): use multiply sign, division sign"
  artifacts:
    - path: "src/components/Display.tsx"
      provides: "Split two-line display with expression and result lines"
      min_lines: 30
    - path: "src/components/ModeToggle.tsx"
      provides: "Simple/Expression mode toggle control"
      exports: ["ModeToggle", "ModeToggleProps"]
    - path: "src/App.tsx"
      provides: "Expression state and mode state management"
      contains: "expressionMode"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/Calculator.tsx"
      via: "props (expression, expressionMode, cursorPosition)"
      pattern: "expression.*mode"
    - from: "src/components/ModeToggle.tsx"
      to: "src/App.tsx"
      via: "onModeChange callback"
      pattern: "onModeChange"
    - from: "src/components/Calculator.tsx"
      to: "src/components/Display.tsx"
      via: "expression and result props"
      pattern: "expression.*result"
---

<objective>
Build the split two-line display (expression top, result bottom), mode toggle UI control, and expression state management in App.tsx. This establishes the visual foundation and state architecture for expression mode.

Purpose: Users need to see their full expression before evaluating it, and need a way to switch between simple and expression modes. This plan creates the visual layout and state plumbing that Plan 03 will wire up with cursor management and full input handling.

Output: Working split display showing expression and result, mode toggle that switches between Simple/Expression modes, expression state in App.tsx.
</objective>

<execution_context>
@/Users/angel-ai/.claude/get-shit-done/workflows/execute-plan.md
@/Users/angel-ai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-expression-parser-foundation/01-01-SUMMARY.md
@src/App.tsx
@src/components/Display.tsx
@src/components/Calculator.tsx
@src/styles/Calculator.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ModeToggle component and redesign Display for split layout</name>
  <files>
    src/components/ModeToggle.tsx
    src/components/Display.tsx
    src/styles/Calculator.css
  </files>
  <action>
**Create `src/components/ModeToggle.tsx`:**

A segmented control with two options: "Simple" and "Expression".

```typescript
export interface ModeToggleProps {
  mode: 'simple' | 'expression';
  onModeChange: (mode: 'simple' | 'expression') => void;
}
```

Implementation:
- Render as a segmented control (two buttons in a container)
- Active segment has highlighted background
- Use CSS classes: `.mode-toggle`, `.mode-toggle__option`, `.mode-toggle__option--active`
- Compact design — sits above the display without taking too much space
- Accessible: use `role="radiogroup"` and `role="radio"` with `aria-checked`

**Redesign `src/components/Display.tsx` for split two-line layout:**

Update the `DisplayProps` interface:
```typescript
export interface DisplayProps {
  value: string;           // Result line (bottom) — used in both modes
  hasMemory: boolean;
  expression?: string;     // Expression line (top) — shown in expression mode
  expressionMode?: boolean; // Whether in expression mode
  cursorPosition?: number; // For cursor rendering (used by Plan 03)
}
```

Implementation:
- **Top line** (`.display__expression`): Shows the expression string with horizontal scroll (`overflow-x: auto`, `white-space: nowrap`). Only visible when `expressionMode` is true and expression is non-empty, OR when there's an expression to show.
- **Bottom line** (`.display__result`): Shows the current value/result. This is the main display in simple mode.
- **Symbol rendering**: Create a `renderExpression()` helper that converts raw operators to math symbols:
  - `*` → `×` (multiplication sign, U+00D7)
  - `/` → `÷` (division sign, U+00F7)
  - Leave `+`, `-`, `(`, `)`, digits, decimal as-is
  - This is display-only — internal state uses raw operators
- **Memory indicator**: Keep the existing `M` indicator in the top-left
- In simple mode: show just the result line (same visual as current calculator)
- In expression mode with no expression yet: show just the result line
- In expression mode with expression: show both lines

**Add CSS in `src/styles/Calculator.css`:**

```css
/* Mode Toggle */
.mode-toggle { ... }          /* Container above display */
.mode-toggle__option { ... }  /* Each segment button */
.mode-toggle__option--active { ... }  /* Active segment */

/* Split Display */
.display__expression { ... }  /* Top line: smaller font, gray text, horizontal scroll */
.display__result { ... }      /* Bottom line: large font, main result */
```

Style details:
- Mode toggle: compact, rounded, subtle background, matches calculator dark theme
- Expression line: `font-size: 1rem`, `color: #aaa`, `overflow-x: auto`, `white-space: nowrap`, `text-align: right`, `min-height: 24px`
- Result line: keeps existing `.display` sizing (2.5rem)
- Expression line scrolls horizontally with most recent input visible (scroll to right end)
- Display container preserves current green-tinted LCD look
- Responsive: mode toggle and expression line scale down on mobile breakpoints
  </action>
  <verify>
Run `npm run build` — no TypeScript errors.
Visually: ModeToggle renders above display with two segments. Display shows split layout when expression mode is active.
  </verify>
  <done>
ModeToggle component renders a segmented control. Display component supports split two-line layout with expression on top and result on bottom. Math symbols render correctly in expression display. CSS styles match calculator dark theme.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire expression state and mode toggle into App.tsx and Calculator.tsx</name>
  <files>
    src/App.tsx
    src/components/Calculator.tsx
  </files>
  <action>
**Update `src/App.tsx` with expression state:**

Add new state variables:
```typescript
const [expressionMode, setExpressionMode] = useState<'simple' | 'expression'>('simple');
const [expression, setExpression] = useState('');        // The expression string being built
const [cursorPosition, setCursorPosition] = useState(0); // Cursor position within expression
const [previewResult, setPreviewResult] = useState('');   // Live result preview
```

Import `ExpressionMode` type from `src/logic/expressionParser.ts` (from Plan 01).

**Add mode toggle handler:**
```typescript
const handleModeChange = useCallback((mode: 'simple' | 'expression') => {
  setExpressionMode(mode);
  // Per user decision: preserve current value when switching modes
  // When switching TO expression mode: expression starts empty, display value preserved as result
  // When switching FROM expression mode: current result becomes display value
  if (mode === 'expression') {
    setExpression('');
    setCursorPosition(0);
    setPreviewResult(displayValue);
  }
  // Simple mode: displayValue is already the current value, just clear expression state
  if (mode === 'simple') {
    setExpression('');
    setCursorPosition(0);
    setPreviewResult('');
  }
}, [displayValue]);
```

**Update `handleButtonClick` for basic expression mode input:**

In expression mode, when user presses digit/operator/decimal buttons:
- Instead of modifying `displayValue` directly, append to `expression` at `cursorPosition`
- Update `cursorPosition` accordingly
- Attempt to evaluate `expression` using `evaluateExpression()` from Plan 01
- If evaluation returns `status: 'success'`, update `previewResult` with the formatted result
- If evaluation returns `status: 'error'` or `'incomplete'`, clear `previewResult` (don't show partial errors — per decision: live preview only when expression is complete and evaluable)
- On `=` in expression mode: evaluate, if success → set `displayValue` to result, create history entry, clear expression. If error → set `previewResult` to "Syntax Error", keep expression visible.
- On `C` in expression mode: clear expression, cursorPosition, previewResult, and displayValue

Simple mode: keep existing `handleButtonClick` logic unchanged (exact same behavior as before).

Import `evaluateExpression` from `src/logic/expressionParser.ts`.

**Update `src/components/Calculator.tsx`:**

Add new props to `CalculatorProps`:
```typescript
expressionMode: 'simple' | 'expression';
expression: string;
cursorPosition: number;
previewResult: string;
onModeChange: (mode: 'simple' | 'expression') => void;
```

Render:
1. `<ModeToggle>` above the Display
2. Pass expression props to `<Display>`
3. In expression mode: Display shows `expression` on top line, `previewResult` (or `displayValue` when no preview) on bottom line
4. In simple mode: Display shows only `displayValue` on bottom line (identical to current behavior)

Pass all new props from App.tsx through Calculator to Display/ModeToggle.
  </action>
  <verify>
Run `npm run build` — no TypeScript errors.
Run `npm test -- --run` — existing tests still pass (no regressions).
Visually: Mode toggle appears. Clicking "Expression" switches mode. Display shows expression line when typing in expression mode. Simple mode looks identical to current calculator.
  </verify>
  <done>
App.tsx manages expression state (expression string, cursor position, mode, preview result). Mode toggle switches between Simple and Expression modes preserving display value. Expression mode appends button presses to expression string and shows live preview when evaluable. Simple mode behavior is unchanged from existing implementation. Calculator.tsx passes all props correctly.
  </done>
</task>

</tasks>

<verification>
```bash
npm run build
npm test -- --run
```
Build passes with no type errors. Existing tests pass. Mode toggle visible and functional. Expression mode shows expression on top line, result on bottom. Simple mode looks identical to before.
</verification>

<success_criteria>
- Mode toggle renders above display with "Simple" and "Expression" options
- Default mode is "Simple" on page load
- Switching to "Expression" mode shows split display layout
- Typing in expression mode builds expression string visible on top line
- Math symbols (multiply, division) render in expression display instead of raw *, /
- Pressing = in expression mode evaluates with PEMDAS
- Simple mode behavior is unchanged (no visual or functional regression)
- Build passes, existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-expression-parser-foundation/01-02-SUMMARY.md`
</output>
