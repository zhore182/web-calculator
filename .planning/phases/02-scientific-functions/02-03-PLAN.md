---
phase: 02-scientific-functions
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/components/Autocomplete.tsx
  - src/App.tsx
  - src/hooks/useKeyboardInput.ts
  - src/styles/Calculator.css
  - src/components/Display.tsx
  - src/components/Calculator.tsx
autonomous: true

must_haves:
  truths:
    - "Typing 'si' in expression mode shows autocomplete popup with 'sin', 'sinh'"
    - "Selecting from autocomplete inserts the function into expression with smart wrap"
    - "Autocomplete disappears when selection is made or expression changes to non-matching"
    - "Keyboard arrow down/up navigates autocomplete options, Enter selects"
    - "Typing scientific function names via keyboard works end-to-end"
  artifacts:
    - path: "src/components/Autocomplete.tsx"
      provides: "Lightweight autocomplete popup for function names"
      exports: ["Autocomplete"]
    - path: "src/App.tsx"
      provides: "Autocomplete state management and keyboard integration"
      contains: "autocomplete"
  key_links:
    - from: "src/components/Autocomplete.tsx"
      to: "src/App.tsx"
      via: "onSelect callback triggering insertFunction"
      pattern: "onSelect"
    - from: "src/hooks/useKeyboardInput.ts"
      to: "src/App.tsx"
      via: "letter key routing for function name typing"
      pattern: "a-z"
---

<objective>
Add keyboard autocomplete popup for scientific function names, enabling users to type function names directly.

Purpose: Users need to type function names via keyboard (not just buttons). After typing 2-3 characters, an autocomplete popup appears showing matching function names (e.g., typing "si" shows "sin", "sinh") for quick selection. Per user decision, the autocomplete should feel lightweight, not a heavy dropdown.

Output: Autocomplete component, keyboard letter input routing in expression mode, autocomplete state management, and full keyboard-to-function pipeline.
</objective>

<execution_context>
@/Users/angel-ai/.claude/get-shit-done/workflows/execute-plan.md
@/Users/angel-ai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scientific-functions/02-01-SUMMARY.md
@.planning/phases/02-scientific-functions/02-02-SUMMARY.md
@src/App.tsx
@src/hooks/useKeyboardInput.ts
@src/components/Display.tsx
@src/components/Calculator.tsx
@src/styles/Calculator.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Autocomplete component and letter input routing</name>
  <files>src/components/Autocomplete.tsx, src/styles/Calculator.css</files>
  <action>
Create a lightweight autocomplete popup component:

**Autocomplete.tsx:**

```typescript
export interface AutocompleteProps {
  matches: string[];          // Filtered function name matches
  selectedIndex: number;      // Currently highlighted index
  onSelect: (funcName: string) => void;
  visible: boolean;
}
```

The component renders a small floating list positioned below the expression input area. Design principles (per user decision): "lightweight, not a heavy dropdown — just enough to disambiguate."

Implementation:
- Only render when `visible` is true and `matches.length > 0`
- Render a `<ul>` with each match as a `<li>`
- Highlighted item (at `selectedIndex`) gets an active class
- Each item is clickable (calls `onSelect(funcName)`)
- Show the function name with the typed portion highlighted/bold
- Maximum 5 items shown (scroll if more, though unlikely)

```tsx
export function Autocomplete({ matches, selectedIndex, onSelect, visible }: AutocompleteProps) {
  if (!visible || matches.length === 0) return null;

  return (
    <div className="autocomplete">
      <ul className="autocomplete__list">
        {matches.map((name, i) => (
          <li
            key={name}
            className={`autocomplete__item ${i === selectedIndex ? 'autocomplete__item--active' : ''}`}
            onClick={() => onSelect(name)}
          >
            {name}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**CSS styling (add to Calculator.css):**

```css
.autocomplete {
  position: absolute;
  top: 100%;
  left: 8px;
  z-index: 10;
  background: #fff;
  border: 1px solid #ccc;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.12);
  min-width: 100px;
  max-width: 160px;
  overflow: hidden;
}

.autocomplete__list {
  list-style: none;
  margin: 0;
  padding: 4px 0;
}

.autocomplete__item {
  padding: 4px 12px;
  font-size: 0.85rem;
  font-family: 'Courier New', monospace;
  cursor: pointer;
  color: #333;
}

.autocomplete__item:hover,
.autocomplete__item--active {
  background: #e8f0fe;
  color: #1a73e8;
}
```

Ensure the display container (parent) has `position: relative` so the autocomplete positions correctly.
  </action>
  <verify>
Run `npm run build` — no TypeScript errors.
Component renders correctly when props are provided.
  </verify>
  <done>
Autocomplete component renders a lightweight floating list below the display area. Styled to be minimal and non-intrusive. Supports mouse click selection and highlights active item.
  </done>
</task>

<task type="auto">
  <name>Task 2: Autocomplete state management and keyboard integration</name>
  <files>src/App.tsx, src/hooks/useKeyboardInput.ts, src/components/Calculator.tsx, src/components/Display.tsx</files>
  <action>
**Define the available function names list (in App.tsx or a constants file):**

```typescript
const SCIENTIFIC_FUNCTIONS = [
  'sin', 'cos', 'tan', 'asin', 'acos', 'atan',
  'sinh', 'cosh', 'tanh', 'asinh', 'acosh', 'atanh',
  'log', 'ln', 'sqrt', 'cbrt', 'abs', 'nthRoot'
];
```

**App.tsx — Add autocomplete state:**

```typescript
const [typingBuffer, setTypingBuffer] = useState('');        // Letters typed so far
const [autocompleteMatches, setAutocompleteMatches] = useState<string[]>([]);
const [autocompleteIndex, setAutocompleteIndex] = useState(0);
const [autocompleteVisible, setAutocompleteVisible] = useState(false);
```

**Letter input handling in expression mode:**

When a lowercase letter key is pressed (a-z) in expression mode:
1. Append to `typingBuffer`
2. Filter `SCIENTIFIC_FUNCTIONS` for names starting with the new buffer
3. If buffer length >= 2 and there are matches → show autocomplete
4. If buffer length >= 2 and no matches → hide autocomplete, clear buffer
5. If exactly one match and buffer equals the match → auto-select it (optional optimization)

```typescript
// In handleButtonClick, expression mode section:
if (/^[a-z]$/.test(value)) {
  const newBuffer = typingBuffer + value;
  setTypingBuffer(newBuffer);

  // Also insert the letter into the expression at cursor
  const { expression: newExpr, cursorPosition: newCursor } = insertAtCursor(expression, cursorPosition, value);
  setExpression(newExpr);
  setCursorPosition(newCursor);

  // Filter matches
  if (newBuffer.length >= 2) {
    const matches = SCIENTIFIC_FUNCTIONS.filter(fn => fn.startsWith(newBuffer));
    if (matches.length > 0) {
      setAutocompleteMatches(matches);
      setAutocompleteIndex(0);
      setAutocompleteVisible(true);
    } else {
      setAutocompleteVisible(false);
    }
  }

  // Try live preview
  const result = evaluateExpression(newExpr, angleMode);
  if (result.status === 'success' && result.display) {
    setPreviewResult(result.display);
  } else {
    setPreviewResult('');
  }
  return;
}
```

**Autocomplete selection handler:**

When user selects a function from autocomplete (click or Enter):
1. Remove the typed buffer characters from expression (they were inserted as raw letters)
2. Call `insertFunction` with the selected function name at the position before the buffer started
3. Clear autocomplete state

```typescript
const handleAutocompleteSelect = useCallback((funcName: string) => {
  // Remove the typed buffer from expression
  const bufferStart = cursorPosition - typingBuffer.length;
  const exprWithoutBuffer = expression.slice(0, bufferStart) + expression.slice(cursorPosition);

  // Insert function at buffer start position
  const { expression: newExpr, cursorPosition: newCursor } = insertFunction(
    exprWithoutBuffer, bufferStart, funcName
  );

  setExpression(newExpr);
  setCursorPosition(newCursor);
  setTypingBuffer('');
  setAutocompleteVisible(false);
  setAutocompleteMatches([]);
  setAutocompleteIndex(0);

  // Try live preview
  const result = evaluateExpression(newExpr, angleMode);
  if (result.status === 'success' && result.display) {
    setPreviewResult(result.display);
  } else {
    setPreviewResult('');
  }
}, [expression, cursorPosition, typingBuffer, angleMode]);
```

**Keyboard navigation for autocomplete:**

When autocomplete is visible, arrow up/down and Enter have special behavior:
- ArrowDown → increment autocompleteIndex (wrap around)
- ArrowUp → decrement autocompleteIndex (wrap around)
- Enter → select current match (call handleAutocompleteSelect)
- Escape → hide autocomplete, clear buffer

Add this BEFORE the normal arrow key handling in expression mode:
```typescript
if (autocompleteVisible) {
  if (value === 'ArrowDown') {
    setAutocompleteIndex(prev => (prev + 1) % autocompleteMatches.length);
    return;
  }
  if (value === 'ArrowUp') {
    setAutocompleteIndex(prev => (prev - 1 + autocompleteMatches.length) % autocompleteMatches.length);
    return;
  }
  if (value === 'Enter') {
    handleAutocompleteSelect(autocompleteMatches[autocompleteIndex]);
    return;
  }
  if (value === 'Escape') {
    setAutocompleteVisible(false);
    setTypingBuffer('');
    return;
  }
}
```

**Clear typing buffer on non-letter input:**

Any non-letter input (digit, operator, etc.) should clear the typing buffer and hide autocomplete:
```typescript
// At the top of expression mode handling, after autocomplete keyboard check:
if (!/^[a-z]$/.test(value) && value !== 'ArrowDown' && value !== 'ArrowUp' && value !== 'Enter' && value !== 'Escape') {
  if (typingBuffer) {
    setTypingBuffer('');
    setAutocompleteVisible(false);
  }
}
```

**useKeyboardInput.ts — Add letter key support:**

Update the keyboard handler to pass lowercase letter keys (a-z) through to handleButtonClick when in expression mode. Currently only digits, operators, and special keys are handled. Add:
```typescript
// Pass letter keys for function name typing (expression mode handles routing)
if (key >= 'a' && key <= 'z') {
  callback(key);
  return;
}
```

Also add Enter key support (separate from '=' for autocomplete):
```typescript
if (key === 'Enter' && autocomplete is visible) → pass 'Enter' instead of '='
```

Actually, simpler: always pass the raw key. In the existing hook, `Enter` maps to `=`. When autocomplete is visible, the App.tsx handler intercepts `Enter` before it reaches `=` handling. But we need `Enter` to be passed as `Enter` not `=` when autocomplete is visible.

Better approach: In useKeyboardInput, pass `Enter` as `'Enter'` instead of `'='`. Then in App.tsx, handle `Enter` the same as `=` for evaluation, BUT check autocomplete first. Update the existing `value === '='` check to also include `value === 'Enter'` (when autocomplete is not visible).

**Calculator.tsx — Pass autocomplete props:**

Add to CalculatorProps and pass through:
```typescript
autocompleteMatches: string[];
autocompleteIndex: number;
autocompleteVisible: boolean;
onAutocompleteSelect: (funcName: string) => void;
```

Render the Autocomplete component inside the calculator div, positioned relative to the display.

**Display.tsx or Calculator.tsx — Render autocomplete:**

Place `<Autocomplete />` after the Display component within the calculator container (which should have `position: relative`).
  </action>
  <verify>
Run `npm run build` — no TypeScript errors.
Run `npx vitest run` — all tests pass.
Verify in dev server (`npm run dev`):
1. Switch to Expression mode
2. Type "si" on keyboard → autocomplete shows "sin", "sinh"
3. Press ArrowDown to highlight "sinh", press Enter → "sinh()" inserted
4. Clear, type "45", then trigger sin button → "sin(45)" with smart wrap
5. Type "sq" → shows "sqrt", press Enter → "sqrt()" inserted
6. Type "lo" → shows "log", "ln" — wait, "ln" doesn't start with "lo". Shows "log" only.
7. Press Escape → autocomplete hides
8. Type random letters that don't match → autocomplete stays hidden
  </verify>
  <done>
Autocomplete popup appears after typing 2+ letters matching a scientific function name. ArrowUp/Down navigates options, Enter selects, Escape dismisses. Selection inserts function with smart wrap. Letter keys route through keyboard input handler. Typing buffer clears on non-letter input. All tests pass, build succeeds.
  </done>
</task>

</tasks>

<verification>
- `npm run build` — no TypeScript errors
- `npx vitest run` — all tests pass
- Type "sin" on keyboard → autocomplete appears at "si", selecting "sin" inserts function
- Type "sqrt" → autocomplete at "sq", selecting "sqrt" inserts function
- Arrow keys navigate autocomplete, Enter selects, Escape dismisses
- Non-letter input clears autocomplete
- Complete keyboard-driven scientific calculation: type "sin(90)" + Enter evaluates to 1 in DEG mode
</verification>

<success_criteria>
Autocomplete popup shows matching function names after 2+ letter characters typed. Keyboard navigation (up/down/enter/escape) works. Function selection inserts into expression with smart wrap. Full keyboard-to-function pipeline works end-to-end. All tests pass, build succeeds.
</success_criteria>

<output>
After completion, create `.planning/phases/02-scientific-functions/02-03-SUMMARY.md`
</output>
