---
phase: 02-scientific-functions
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/logic/expressionParser.ts
  - src/logic/expressionParser.test.ts
autonomous: true

must_haves:
  truths:
    - "sin(90) in DEG mode returns 1, sin(pi/2) in RAD mode returns 1"
    - "log(100) returns 2, ln(e) returns 1"
    - "sqrt(-1) returns specific error 'Cannot take sqrt of negative number'"
    - "1/0 returns specific error 'Cannot divide by zero'"
    - "3.5! returns specific error 'Factorial requires non-negative integer'"
    - "5! returns 120, abs(-7) returns 7, 50% returns 0.5"
    - "2^3 returns 8, cbrt(27) returns 3"
    - "asin(0.5) returns 30 in DEG mode"
    - "sinh(1), cosh(1), tanh(1) return correct values"
  artifacts:
    - path: "src/logic/expressionParser.ts"
      provides: "Scientific expression evaluation with angle mode and domain error handling"
      exports: ["evaluateExpression", "formatResult", "ExpressionResult", "ExpressionMode", "AngleMode"]
    - path: "src/logic/expressionParser.test.ts"
      provides: "Comprehensive test suite for all scientific functions"
      min_lines: 300
  key_links:
    - from: "src/logic/expressionParser.ts"
      to: "mathjs"
      via: "evaluate() with custom scope for angle mode"
      pattern: "evaluate.*scope"
---

<objective>
Extend the expression parser with scientific function evaluation, angle mode (DEG/RAD) support, and domain-specific error messages.

Purpose: All 11 scientific requirements (SCI-01 through SCI-10, MODE-02) depend on the evaluation engine correctly computing scientific functions and providing meaningful error messages. This is the foundation for the entire phase.

Output: Extended `evaluateExpression()` that accepts an angle mode parameter, evaluates all scientific functions (trig, inverse trig, hyperbolic, log, ln, powers, roots, factorial, abs, percentage), and returns specific domain error messages instead of generic "Syntax Error".
</objective>

<execution_context>
@/Users/angel-ai/.claude/get-shit-done/workflows/execute-plan.md
@/Users/angel-ai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-expression-parser-foundation/01-01-SUMMARY.md
@src/logic/expressionParser.ts
@src/logic/expressionParser.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scientific evaluation engine with angle mode and domain errors (TDD)</name>
  <files>src/logic/expressionParser.ts, src/logic/expressionParser.test.ts</files>
  <action>
**RED phase — Write failing tests first:**

Add a new `AngleMode` type export: `type AngleMode = 'DEG' | 'RAD';`

Update `evaluateExpression` signature to accept optional angle mode:
`evaluateExpression(expr: string, angleMode: AngleMode = 'DEG'): ExpressionResult`

Write tests for ALL of the following (organized by requirement):

**SCI-01: Trig functions with angle mode**
- `sin(90)` in DEG → 1
- `cos(0)` in DEG → 1
- `tan(45)` in DEG → 1
- `sin(${Math.PI/2})` in RAD → 1 (use `sin(pi/2)` — mathjs supports `pi`)
- `cos(pi)` in RAD → -1

**SCI-02: Inverse trig**
- `asin(1)` in DEG → 90
- `acos(0)` in DEG → 90
- `atan(1)` in DEG → 45
- `asin(1)` in RAD → ~1.5708 (pi/2)

**SCI-03: Hyperbolic functions**
- `sinh(0)` → 0
- `cosh(0)` → 1
- `tanh(0)` → 0
- `asinh(0)` → 0
- `acosh(1)` → 0
- `atanh(0)` → 0

**SCI-04: Logarithms**
- `log(100)` → 2 (log base 10 — NOTE: mathjs `log10()`)
- `log(1)` → 0
- `ln(e)` → 1 (natural log — NOTE: mathjs uses `log()` for natural log)
- `ln(1)` → 0

**SCI-05: Exponentiation**
- `2^2` → 4 (x^2)
- `2^3` → 8 (x^3)
- `2^10` → 1024 (x^y)

**SCI-06: Roots**
- `sqrt(16)` → 4
- `sqrt(2)` → ~1.41421356237
- `cbrt(27)` → 3
- `nthRoot(16, 4)` → 2

**SCI-07: Constants**
- `pi` → ~3.14159265359
- `e` → ~2.71828182846
- `2*pi` → ~6.28318530718
- `2pi` → ~6.28318530718 (implicit multiplication)

**SCI-08: Factorial**
- `5!` → 120
- `0!` → 1
- `10!` → 3628800

**SCI-09: Absolute value**
- `abs(-5)` → 5
- `abs(3)` → 3

**SCI-10: Percentage**
- `50%` → 0.5 (per user decision: percentage = divide by 100)
- `200*50%` → 100

**MODE-02: Angle mode affects trig** (covered in SCI-01/SCI-02 tests above)

**Domain error tests:**
- `sqrt(-1)` → error: "Cannot take sqrt of negative number"
- `1/0` → error: "Cannot divide by zero"
- `3.5!` → error: "Factorial requires non-negative integer"
- `(-1)!` → error: "Factorial requires non-negative integer"
- `asin(2)` → error (asin domain is [-1, 1])

Run tests — they MUST fail (RED).

**GREEN phase — Implement:**

Modify `evaluateExpression()` in expressionParser.ts:

1. **Angle mode handling:** Create a mathjs scope object. For DEG mode, override trig functions to convert degrees to radians before computation, and inverse trig functions to convert radians to degrees after computation. For RAD mode, use mathjs defaults.

   Implementation approach: Use mathjs `evaluate()` with a custom scope that provides DEG-aware wrappers:
   ```typescript
   const degScope = {
     sin: (x: number) => Math.sin(x * Math.PI / 180),
     cos: (x: number) => Math.cos(x * Math.PI / 180),
     tan: (x: number) => Math.tan(x * Math.PI / 180),
     asin: (x: number) => Math.asin(x) * 180 / Math.PI,
     acos: (x: number) => Math.acos(x) * 180 / Math.PI,
     atan: (x: number) => Math.atan(x) * 180 / Math.PI,
   };
   ```
   Hyperbolic functions are NOT affected by angle mode (they use radians always).

2. **Log aliasing:** mathjs uses `log()` for natural log and `log10()` for base-10. Per requirements, user expects `log()` = base 10, `ln()` = natural log. Create scope aliases:
   ```typescript
   scope.log = (x: number) => Math.log10(x);
   scope.ln = (x: number) => Math.log(x);
   ```

3. **Percentage operator:** Pre-process the expression to replace `%` with `/100`. Use regex: `expr.replace(/(\d+(?:\.\d+)?)%/g, '($1/100)')`. This makes `50%` → `(50/100)` and `200*50%` → `200*(50/100)`.

4. **Domain error detection:** After evaluation, check for specific error patterns in the caught error message. Map to user-friendly messages:
   - If expression contains `sqrt` and mathjs error → check if argument is negative → "Cannot take sqrt of negative number"
   - Division by zero: Check if result is Infinity or -Infinity → "Cannot divide by zero"
   - Factorial of non-integer: Pre-validate factorial expressions using regex `(\d+\.?\d*)!` — if the number has a decimal or is negative → "Factorial requires non-negative integer"

   Better approach for factorial: Pre-process the expression. Find all `N!` patterns. For each, check if N is a non-negative integer. If not, return domain error immediately before calling mathjs.

5. **Division by zero:** After evaluation, check `!isFinite(result)` — return error "Cannot divide by zero" instead of generic "Syntax Error". Update the existing NaN/Infinity check to return the specific message.

Run tests — they MUST pass (GREEN).

**REFACTOR phase:** Clean up, ensure no code duplication, verify all exports are properly typed.
  </action>
  <verify>
Run `npx vitest run src/logic/expressionParser.test.ts` — all tests pass.
Run `npm run build` — no TypeScript errors.
Verify at least 40+ test cases covering all scientific functions.
  </verify>
  <done>
evaluateExpression() handles all scientific functions (trig, inverse trig, hyperbolic, log, ln, powers, roots, factorial, abs, percentage) with DEG/RAD angle mode support. Domain errors return specific user-friendly messages. All tests pass. Build succeeds.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run` — all tests pass (existing + new)
- `npm run build` — no TypeScript errors
- New `AngleMode` type exported from expressionParser.ts
- `evaluateExpression("sin(90)", "DEG")` returns `{ status: 'success', value: 1, display: '1' }`
- `evaluateExpression("sqrt(-1)")` returns `{ status: 'error', error: 'Cannot take sqrt of negative number' }`
- `evaluateExpression("1/0")` returns `{ status: 'error', error: 'Cannot divide by zero' }`
</verification>

<success_criteria>
All scientific functions evaluate correctly with proper angle mode handling. Domain errors produce specific user-friendly messages. Test suite covers all 11 requirements (SCI-01 through SCI-10 + MODE-02). Build passes.
</success_criteria>

<output>
After completion, create `.planning/phases/02-scientific-functions/02-01-SUMMARY.md`
</output>
