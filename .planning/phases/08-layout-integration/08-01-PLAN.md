---
phase: 08-layout-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/App.tsx
  - src/components/Calculator.tsx
  - src/components/ModeToggle.tsx
  - src/styles/Calculator.css
autonomous: false

must_haves:
  truths:
    - "User can toggle between calculator mode and graph mode via a single control"
    - "Graph fills the main area (replacing button panel) in graph mode"
    - "Expression display remains visible on top in graph mode"
    - "Layout maintains clear visual hierarchy in both modes"
    - "Mode switch is visually obvious and accessible"
  artifacts:
    - path: "src/App.tsx"
      provides: "appMode state ('calc' | 'graph') and mode toggle handler"
      contains: "appMode"
    - path: "src/components/Calculator.tsx"
      provides: "Conditional layout rendering based on appMode"
      contains: "appMode"
    - path: "src/components/ModeToggle.tsx"
      provides: "Three-option mode toggle: Simple | Expression | Graph"
      contains: "graph"
    - path: "src/styles/Calculator.css"
      provides: "Graph-mode layout with graph filling main content area"
      contains: "calculator--graph-mode"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/Calculator.tsx"
      via: "appMode prop"
      pattern: "appMode={appMode}"
    - from: "src/components/Calculator.tsx"
      to: "src/styles/Calculator.css"
      via: "conditional CSS classes"
      pattern: "calculator--graph-mode"
    - from: "src/components/ModeToggle.tsx"
      to: "src/App.tsx"
      via: "onAppModeChange callback"
      pattern: "onAppModeChange"
---

<objective>
Implement calculator/graph mode switching so users can toggle between a calculator view (buttons + display) and a graph view (graph filling the main content area with display remaining on top).

Purpose: This is the core layout integration that unifies the calculator and graphing features into a single-mode interface, replacing the current "graph appended below everything" approach.
Output: Working mode toggle between calculator and graph views with proper layout switching.
</objective>

<execution_context>
@/Users/angel-ai/.claude/get-shit-done/workflows/execute-plan.md
@/Users/angel-ai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/App.tsx
@src/components/Calculator.tsx
@src/components/ModeToggle.tsx
@src/components/GraphPanel.tsx
@src/styles/Calculator.css
@src/styles/design-tokens.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add app-level mode state and extend mode toggle</name>
  <files>src/App.tsx, src/components/ModeToggle.tsx, src/components/Calculator.tsx</files>
  <action>
**ModeToggle.tsx — extend to support three modes:**
- Change the component to support an `appMode` prop of type `'calc' | 'graph'` alongside the existing `expressionMode` (simple/expression).
- Replace the two-button toggle with a three-option toggle: "Simple" | "Expression" | "Graph".
- "Simple" sets expressionMode='simple' and appMode='calc'.
- "Expression" sets expressionMode='expression' and appMode='calc'.
- "Graph" sets appMode='graph' (expressionMode stays whatever it was — expression mode is the natural companion to graphing).
- Use the existing `.mode-toggle` and `.mode-toggle__option` CSS classes. The active state class `.mode-toggle__option--active` applies to the selected option.
- Add `aria-label="Calculator mode"` to the container and `role="radio"` / `aria-checked` to each button (already present, extend to third option).
- Add `data-testid="mode-graph"` to the Graph button.

**App.tsx — add appMode state:**
- Add state: `const [appMode, setAppMode] = useState<'calc' | 'graph'>('calc');`
- Create handler `handleAppModeChange` that:
  - Sets appMode to 'calc' or 'graph'
  - When switching TO graph mode: automatically set expressionMode to 'expression' if it was 'simple' (graph mode works with expression mode). Also, if graphExpression is empty but there's a current expression, pre-fill graphInputValue with it.
  - When switching FROM graph mode back to calc: keep current state, no resets needed.
- Update the ModeToggle props to pass both `expressionMode`, `appMode`, `onModeChange` (for simple/expression), and `onAppModeChange` (for calc/graph). OR refactor into a single `onModeSelect` callback that receives which of the three options was clicked and App.tsx handles the logic. The second approach is cleaner — use it.
- Pass `appMode` as a new prop to Calculator component.
- When `appMode === 'graph'`: automatically set `graphVisible` to true (the graph should always be visible in graph mode).
- Remove the separate graph-controls input row and plot/clear buttons from the Calculator in graph mode — graph mode shows the graph directly using the current expression. The graph input field and plot/clear buttons should only appear in calc mode (they are the v1.0 approach being replaced).

**Calculator.tsx — accept appMode prop:**
- Add `appMode: 'calc' | 'graph'` to CalculatorProps interface.
- For now just accept and pass through; Task 2 handles layout changes.

**ModeToggle refactor detail:**
- The component receives: `expressionMode: 'simple' | 'expression'`, `appMode: 'calc' | 'graph'`, `onModeSelect: (mode: 'simple' | 'expression' | 'graph') => void`
- Active state logic: if appMode is 'graph', the Graph button is active. If appMode is 'calc', whichever of Simple/Expression matches expressionMode is active.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Run `npm run build` — builds successfully. The app should render without crashes, showing three mode options in the toggle.
  </verify>
  <done>
ModeToggle shows three options (Simple, Expression, Graph). Clicking Graph sets appMode to 'graph'. Clicking Simple or Expression sets appMode to 'calc' with the respective expression mode. App.tsx manages appMode state and passes it to Calculator.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement conditional layout for calculator vs graph mode</name>
  <files>src/components/Calculator.tsx, src/styles/Calculator.css</files>
  <action>
**Calculator.tsx — conditional rendering based on appMode:**

The layout changes between modes:

**Calculator mode (appMode === 'calc'):**
- Render exactly as today: mode toggle, SCI toggle, display, panels (scientific + buttons), graph controls, graph panel (if visible), history.
- This is the existing layout, no changes.

**Graph mode (appMode === 'graph'):**
- Render: mode toggle at top, display (expression + result visible), then GraphPanel filling the main content area where buttons normally are.
- HIDE: SCI toggle, scientific panel, button panel, graph-controls input row, history panel.
- The GraphPanel should expand to fill the available space — remove the fixed 200px height and let it grow. Use a wrapper div with class `calculator__graph-main` that has `flex: 1` and `min-height: 280px`.
- Graph zoom/pan/trace controls remain as overlays within GraphPanel (they already are).
- The graph expression in graph mode comes from the current `expression` state (what user typed in the expression display). This wiring happens via the `graphExpression` prop which App.tsx already manages.

**Calculator.tsx implementation:**
```
const isGraphMode = appMode === 'graph';

// Calculator container class
const calculatorClassName = [
  'calculator',
  scientificPanelOpen && !isGraphMode ? 'calculator--sci-open' : '',
  isGraphMode ? 'calculator--graph-mode' : '',
].filter(Boolean).join(' ');
```

In the JSX:
- Mode toggle: always rendered
- SCI toggle: `{!isGraphMode && <button ...>SCI</button>}`
- Display: always rendered
- Autocomplete: always rendered (works with expression display)
- Calculator panels (scientific + buttons): `{!isGraphMode && <div className="calculator__panels">...</div>}`
- Graph controls (input row + plot/clear): `{!isGraphMode && <div className="graph-controls">...</div>}`
- GraphPanel: In graph mode, wrap in `<div className="calculator__graph-main">` and pass `visible={true}`. In calc mode, render as before.
- History: `{!isGraphMode && <HistoryPanel ... />}`

**Calculator.css — graph mode styles:**

Add these new rules:

```css
/* Graph mode layout */
.calculator--graph-mode {
  display: flex;
  flex-direction: column;
  max-width: 320px; /* Same width as calculator mode for consistency */
}

.calculator__graph-main {
  flex: 1;
  min-height: 280px;
  margin-top: var(--space-3);
}

/* In graph mode, the graph panel should not have top margin/border — it IS the main content */
.calculator--graph-mode .graph-panel {
  margin-top: 0;
  border-top: none;
  padding-top: 0;
}

/* Graph canvas fills the container in graph mode */
.calculator--graph-mode .graph-panel__canvas {
  height: 100%;
  min-height: 280px;
}
```

Update responsive breakpoints: in graph mode on mobile, the graph-main area should use `min-height: 220px` (phone) and `min-height: 200px` (narrow phone).

Do NOT change the existing calc-mode CSS. Only add new rules scoped to `.calculator--graph-mode`.
  </action>
  <verify>
Run `npm run build` — builds successfully. Run `npm run dev` and manually test:
1. Click "Graph" — button panel disappears, graph fills main area, display stays on top
2. Click "Simple" or "Expression" — button panel returns, graph goes back to its old position
3. In graph mode, expression display is visible and editable
4. Graph canvas fills the available space (not 200px tall)
  </verify>
  <done>
In calculator mode, layout is unchanged from current behavior. In graph mode, button panel and graph controls are hidden, graph fills main content area below the display, expression display remains visible on top, and the layout has clear visual hierarchy with the graph as the primary content area.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete calculator/graph mode switching with layout integration:
- Three-option mode toggle (Simple | Expression | Graph)
- Graph mode: graph fills main area, display stays on top, buttons hidden
- Calculator mode: unchanged from current behavior
- Responsive across desktop, tablet, and mobile
  </what-built>
  <how-to-verify>
1. Run `npm run dev` and open in browser
2. Verify the mode toggle now shows three options: Simple, Expression, Graph
3. Click "Graph" — verify:
   - Button panel disappears
   - Graph fills the main content area (large, not the old 200px)
   - Expression display remains visible on top
   - History panel is hidden
   - Graph controls (zoom, pan, trace) work as overlays
4. Click "Expression" — verify:
   - Button panel returns
   - Graph returns to its old position (below buttons, if visible)
   - Everything works as before
5. Click "Simple" — verify normal calculator mode
6. Test responsive: resize browser to mobile width, verify graph mode layout works
7. Check visual hierarchy: in graph mode, the graph should feel like the primary content, not an afterthought
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no type errors
- `npm run build` succeeds
- Mode toggle shows three options and switches correctly
- Graph mode: graph fills main area, display on top, buttons hidden
- Calculator mode: unchanged from current behavior
- No layout shifts or visual jank when switching modes
</verification>

<success_criteria>
1. User can toggle between calculator mode and graph mode via the mode toggle
2. In graph mode, graph fills the main content area where buttons were
3. Expression display remains visible on top in graph mode
4. Layout maintains clear visual hierarchy in both modes
5. Mode switch control is visually obvious (active state) and accessible (aria attributes)
</success_criteria>

<output>
After completion, create `.planning/phases/08-layout-integration/08-01-SUMMARY.md`
</output>
